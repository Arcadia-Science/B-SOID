function [g_num,perc_unk,trans_p] = bsoid_mt(data,fps,pix_cm,smth_hstry,smth_futr,min_trans) % data{m}, pixel/cm
%BSOID_MT     Classifies mouse open field behavior using manual criterion analyzing DeepLabCut output.
%   
%   [G_LABEL,G_NUM,PERC_UNK] = BSOID_MT(data{m},PIX_CM) outputs classified behaviors based on DeepLabCut analysis
%
%   INPUTS:
%   data{m}    6-body parts (x,y) matrix outlining the tetrapod animal over time videotaped from the bottom looking up. Rows represents time.
%           Columns 1 & 2 tracks snout; columns 3 to 6 tracks the two front paws; columns 7 to 10 tracks the two hind paws;
%           columns 11 & 12 tracks the base of the tail. Tested on tracking data{m} generated by DeepLabCut 2.0.
%   FPS    Rounded frame rate, can use VideoReader/ffmpeg(linux command) to automatically detect the input video fps.
%   PIX_CM    Pixel-to-cm conversion for users zoom. number of frames to average from history, recommended 3
%   SMTH_HSTRY    BOXCAR smoothing using number of frames from before. Default ~40ms before.
%   SMTH_FUTR    BOXCAR smoothing using number of frames from after. Default ~40ms after.
%   MIN_TRANS    Minimum number of frames for transition to occur. Default ~100ms. 
%
%   G_NUM    Classified behavioral state, numbered.
%   PERC_UNK    Percentage of total number of frames that are undefined.
%   TRANS_P     Transition probability matrix with Markov assumption (rows as current, columns as next).
%
%   Created by Alexander Hsu, Date: 051519
%   Contact ahsu2@andrew.cmu.edu

    if nargin < 3
        error('Please input data{m}set, frame rate, pixel-to-cm conversion!')
    end
    if nargin < 4
        smth_hstry = round(0.05/(1/fps));
        smth_futr = round(0.05/(1/fps));
    end
    if nargin < 6
        min_trans = round(0.1/(1/fps))-1;
    end
    fprintf('Obtaining features from dataset... \n');
    for m = 1:length(data) % For each csv file you uploaded.
        data{m} = data{m}*24/pix_cm;
        %% Obtain features
        for i = 1:length(data{m})
            % Chest position
            chest_pos(i,1) = mean([data{m}(i,3),data{m}(i,5)]);
            chest_pos(i,2) = mean([data{m}(i,4),data{m}(i,6)]);
            % Genital position
            gen_pos(i,1) = mean([data{m}(i,7),data{m}(i,9)]);
            gen_pos(i,2) = mean([data{m}(i,8),data{m}(i,10)]);
            % Snout-chest distance
            snchxy_dist(i) = norm((data{m}(i,1:2)-chest_pos(i,1:2)));
            % Snout-butt distance
            snbtxy_dist(i) = norm((data{m}(i,1:2)-data{m}(i,11:12)));
            % Inter-forepaw distance
            fpawRL_dist(i) = norm((data{m}(i,3:4)-data{m}(i,5:6)));
        end
        snchxy_dist_smth = movmean(snchxy_dist,[smth_hstry,smth_futr]);
        snbtxy_dist_smth = movmean(snbtxy_dist,[smth_hstry,smth_futr]);
        fpawRL_dist_smth = movmean(fpawRL_dist,[smth_hstry,smth_futr]);
        for j = 1:length(data{m})
            % Chest-butt distance
            CB(j,1) = chest_pos(j,1) - data{m}(j,11);
            CB(j,2) = chest_pos(j,2) - data{m}(j,12);
            CB_norm(j) = norm(CB(j,:));
            % Genital-butt distance
            GB(j,1) = gen_pos(j,1) - data{m}(j,11);
            GB(j,2) = gen_pos(j,2) - data{m}(j,12);
            % Snout-butt distance
            SB(j,1) = data{m}(j,1) - data{m}(j,11);
            SB(j,2) = data{m}(j,2) - data{m}(j,12);
            SB_norm(j) = norm(SB(j,:));
            % Snout-butt - Genital-butt 
            headrelbod(j) = norm(SB(j,:)-GB(j,:));
        end
        CB_norm_smth = movmean(CB_norm,[smth_hstry,smth_futr]);
        SB_norm_smth = movmean(SB_norm,[smth_hstry,smth_futr]);
        pawrelhead_smth = movmean(SB_norm-CB_norm,[smth_hstry,smth_futr]);
        headrelbod_smth = movmean(headrelbod,[smth_hstry,smth_futr]);
        for k = 1:length(data{m})-1
            % Chest-butt angle
            b_3d = [CB(k+1,:),0]; a_3d = [CB(k,:),0]; c = cross(b_3d,a_3d);
            CB_angle(k) = sign(c(3))*180/pi*atan2(norm(c),dot(CB(k,:),CB(k+1,:)));
            % Genital-butt angle
            b_3d = [GB(k+1,:),0]; a_3d = [GB(k,:),0]; c = cross(b_3d,a_3d);
            GB_angle(k) = sign(c(3))*180/pi*atan2(norm(c),dot(GB(k,:),GB(k+1,:)));
            % Snout-butt angle
            b_3d = [SB(k+1,:),0]; a_3d = [SB(k,:),0]; c = cross(b_3d,a_3d);
            SB_angle(k) = sign(c(3))*180/pi*atan2(norm(c),dot(SB(k,:),SB(k+1,:)));
            % Chest-butt length displacement
            CB_disp(k) = norm(CB(k+1,1:2)-CB(k,1:2));      
            % Snout speed
            snoutxy_disp(k) = norm(data{m}(k+1,1:2)-data{m}(k,1:2));
            % Forepaw speed
            fpawRxy_disp(k) = norm(data{m}(k+1,3:4)-data{m}(k,3:4));
            fpawLxy_disp(k) = norm(data{m}(k+1,5:6)-data{m}(k,5:6));
            % Interpaw speed
            fpawRL_disp(k) = norm(fpawRL_dist(k+1)-fpawRL_dist(k));
            % Hind paw speed
            hpawRxy_disp(k) = norm(data{m}(k+1,7:8)-data{m}(k,7:8));
            hpawLxy_disp(k) = norm(data{m}(k+1,9:10)-data{m}(k,9:10));
            % Butt speed
            buttxy_disp(k) = norm(data{m}(k+1,11:12)-data{m}(k,11:12));
            % Snout-chest speed
            snchxy_dist_disp(k) = snchxy_dist(k+1)-snchxy_dist(k);
            % Snout-butt speed
            snbtxy_dist_disp(k) = snbtxy_dist(k+1)-snbtxy_dist(k);
        end
        hpawRxy_disp_smth = movmean(hpawRxy_disp,[smth_hstry,smth_futr]); hpawLxy_disp_smth = movmean(hpawLxy_disp,[smth_hstry,smth_futr]);
        SB_angle_smth = movmean(SB_angle,[smth_hstry,smth_futr]); CB_angle_smth = movmean(CB_angle,[smth_hstry,smth_futr]); GB_angle_smth = movmean(GB_angle,[smth_hstry,smth_futr]);
        CB_disp_smth = movmean(CB_disp,[smth_hstry,smth_futr]); snoutxy_disp_smth = movmean(snoutxy_disp,[smth_hstry,smth_futr]);
        fpawRxy_disp_smth = movmean(fpawRxy_disp,[smth_hstry,smth_futr]); fpawLxy_disp_smth = movmean(fpawLxy_disp,[smth_hstry,smth_futr]);
        buttxy_disp_smth = movmean(buttxy_disp,[smth_hstry,smth_futr]); fpawRL_disp_smth = movmean(fpawRL_disp,[smth_hstry,smth_futr]);
        snchxy_dist_disp_smth = movmean(snchxy_dist_disp,[smth_hstry,smth_futr]); snbtxy_dist_disp_smth = movmean(snbtxy_dist_disp,[smth_hstry,smth_futr]);
        %% Classify action based on parameters specified above
        %%% Rest/Pause is defined as minimal change in body angle, and minimal displacement of all labels.
        idx_rest{m} = find(abs(SB_angle_smth) < 1 & snoutxy_disp_smth > 0 & snoutxy_disp_smth < 2 & buttxy_disp_smth < 2 & ...
            fpawRxy_disp_smth < 2 & fpawLxy_disp_smth < 2 & pawrelhead_smth(2:end) > 0);
        %%% Rear is defined as either snout is gone, front paws are gone (reared up), or front paws coming together (rearing up).
        idx_rear{m} = find(snoutxy_disp_smth == 0 & abs(SB_angle_smth) < 1 | ... 
            fpawRxy_disp_smth == 0 & abs(SB_angle_smth) < 1 | ... 
            fpawLxy_disp_smth == 0 & abs(SB_angle_smth) < 1 | ...
            snoutxy_disp_smth > 2 & abs(fpawRxy_disp_smth-fpawLxy_disp_smth) < 5 & pawrelhead_smth(2:end) > 0 & ... 
            fpawRL_dist_smth(2:end) < 20 & buttxy_disp_smth >= 2 & fpawRxy_disp_smth >= 2 & fpawLxy_disp_smth >= 2);
        %%% Groom is defined as either snout invisible, front paws visible and close, and no change in angle or tail position
        %%%% snout is visible, front paws in/visible and far, hands are in front of snout, and no change in angle or tail position
        %%%% or snout visibly moving, both front paws visible, one of which moves, and no change in angle or tail position
        idx_groom{m} = find(snoutxy_disp_smth == 0 & fpawRL_dist_smth(2:end) < 10 & fpawRxy_disp_smth >= 2 & abs(SB_angle_smth) < 1 & ...
            buttxy_disp_smth < 2 | snoutxy_disp_smth == 0 & fpawRL_dist_smth(2:end) < 10 & fpawLxy_disp_smth >= 2 & ...
            abs(SB_angle_smth) < 1 & buttxy_disp_smth < 2 | ...
            snoutxy_disp_smth > 0 & fpawRxy_disp_smth >= 2 & abs(SB_angle_smth) < 1 & hpawRxy_disp_smth < 2 & hpawLxy_disp_smth < 2 & buttxy_disp_smth < 2 | ...
            snoutxy_disp_smth > 0 & fpawLxy_disp_smth >= 2 & abs(SB_angle_smth) < 1 & hpawRxy_disp_smth < 2 & hpawLxy_disp_smth < 2 & buttxy_disp_smth < 2 | ...
            snoutxy_disp_smth > 0 & abs(SB_angle_smth) < 1 & pawrelhead_smth(2:end) < 0 & buttxy_disp_smth < 2 | ...
            snoutxy_disp_smth >= 2 & fpawRxy_disp_smth > 0 & fpawLxy_disp_smth > 0 & abs(SB_angle_smth) < 1 & buttxy_disp_smth < 2);
        %%% Orientation of body is defined as non-locomoting body angle change
        idx_ori_right{m} = find(buttxy_disp_smth < 2 & SB_angle_smth >= 1);
        idx_ori_left{m} = find(buttxy_disp_smth < 2 & SB_angle_smth <= -1);
        %%% Locomotion is defined as body displacement with either front paw
        idx_loc{m} = find(buttxy_disp_smth >= 2 & fpawRxy_disp_smth >= 2 | buttxy_disp_smth >= 2 & fpawLxy_disp_smth >= 2 | ...
            buttxy_disp_smth >= 2 & hpawRxy_disp_smth >= 2 | buttxy_disp_smth >= 2 & hpawLxy_disp_smth >= 2);
        %%% Head movement is defined as only snout movement with stationary body, and no change in angle or tail position
        idx_headmov{m} = find(abs(SB_angle_smth) < 1 & snoutxy_disp_smth >= 2 & hpawRxy_disp_smth < 2 & hpawLxy_disp_smth < 2);  
        %% Low pass filter of unreasonable fast state changes
        MC = []; MC(:) = 0; MC(idx_rest{m},1) = 1; MC(idx_rear{m},1) = 2; MC(idx_groom{m},1) = 3; MC(idx_headmov{m},1) = 4; MC(idx_loc{m},1) = 5; 
        MC(idx_ori_left{m},1) = 6; MC(idx_ori_right{m},1) = 7; 
        stch = find(diff(MC)~=0);
        for i = 1:length(stch)-1
            if stch(i+1) - stch(i) <= min_trans
               MC(stch(i):stch(i+1)) = MC(stch(i));
            end
        end
        
        %% Reassign sandwiched unidentified to prior and posterior, if the same 
        for k = 1:length(stch)-2
            if MC(stch(k+1)) == 0 && MC(stch(k)) == MC(stch(k+2))
               MC(stch(k):stch(k+2)) = MC(stch(k));
            end
        end
        g_num{m} = MC;
        %% Pull out transitional probability
        perc_unk{m} = length(find(g_num{m}==0))/(length(data{m})-1); % Undefined percentage
        binEdges = 1:length(MC); [~,states] = histc(nonzeros(MC),binEdges); % Histc just asks which bin each pose belongs to
        binTicks = binEdges(1:end-1); % Don't need the last bin edge
        ActMat = zeros(length(unique(MC))-1); fromBinNos = states(1:end-1); nextBinNos = states(2:end);
        for i = 1:length(fromBinNos)
            ActMat(fromBinNos(i),nextBinNos(i)) = ActMat(fromBinNos(i),nextBinNos(i)) + 1;
        end
        for j = 1:length(unique(MC))-1
            trans_p{m}(j,:) = ActMat(j,:)/sum(ActMat(j,:));
        end
    end

return

